{"version":3,"file":"react-pagex.cjs.production.min.js","sources":["../src/navigate.ts","../src/components/Link.tsx","../src/Parser.ts","../src/core.ts","../src/components/Route.tsx","../src/index.ts","../src/components/Routes.tsx"],"sourcesContent":["const navigate = {\n   go: (path: string) => {\n      window.history.pushState({ pagex: true, path }, \"\", path)\n      dispatchEvent(new PopStateEvent(\"popstate\", { state: { pagex: true, path } }))\n   },\n   reload: () => {\n      dispatchEvent(new PopStateEvent(\"popstate\", {\n         state: {\n            path: window.location.pathname,\n            pagex: true\n         }\n      }))\n   },\n   back: () => window.history.back(),\n   forward: () => window.history.forward()\n}\n\nexport default navigate","import { ComponentType, createElement, FC, ReactElement } from 'react'\nimport navigate from '../navigate'\n\nexport interface LinkProps {\n   children?: string | ReactElement;\n   label?: string;\n   href: string;\n   noHref?: boolean;\n   component?: ComponentType<any>\n}\n\n\nconst Link: FC<LinkProps> = ({ href, noHref, children, label, component }) => {\n   return createElement(component || 'a', {\n      ...(noHref !== false ? { href } : {}),\n      onClick: (e: any) => {\n         e.preventDefault()\n         navigate.go(href)\n      }\n   }, children || label)\n}\n\nexport default Link","import { match } from 'path-to-regexp'\n\n\nexport type Result = {\n   keys: string[];\n   pattern: RegExp;\n}\n\nexport type CallbackProps = { params: { [key: string]: string } }\nexport type Callback = (props: CallbackProps) => any;\n\nconst parseQuery = (q = window.location.search) => {\n   if (!q) return {}\n   const query_string = q.substring(1);\n   const vars = query_string.split('&')\n   const query: { [key: string]: string } = {}\n   for (var i = 0; i < vars.length; i++) {\n      var pair = vars[i].split('=');\n      query[pair[0]] = pair[1]\n      query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1])\n   }\n   return query\n}\n\nconst isMatch = (regex_path: string, path: string) => {\n   const m = match(regex_path, { decode: decodeURIComponent })\n   const matches = m(path)\n   return matches ? matches.params : null\n}\n\nconst Parser = {\n   isMatch,\n   parseQuery\n}\n\nexport default Parser","import { useMemo, useEffect, useState, useId } from 'react'\nimport Parser from \"./Parser\";\n\ntype RouteId = string\ntype GroupId = string\n\nexport interface RoutesProps {\n   dispatch: Function;\n   path: string;\n   params: { [key: string]: any } | false\n}\nexport interface GroupProps {\n   basepath?: string;\n   dispatch: Function;\n   onError?: () => void;\n   onFound?: (route: RoutesProps) => void;\n   routes: Map<RouteId, RoutesProps>\n}\n\ninterface CoreProps {\n   currentGroup: null | string,\n   groups: Map<GroupId, GroupProps>;\n   actives: Map<GroupId, RouteId[]>;\n}\n\nexport const core: CoreProps = {\n   currentGroup: null,\n   groups: new Map<GroupId, GroupProps>(),\n   actives: new Map<GroupId, RouteId[]>()\n}\n\n\nexport const useGroup = (props: Omit<GroupProps, 'routes' | 'dispatch'>) => {\n   const uid = useId()\n   const [d, dispatch] = useState(0)\n   const prevGroupId = useMemo(() => core.currentGroup, [])\n\n   // set current group\n   useMemo(() => {\n      core.currentGroup = uid\n      core.groups.set(uid, {\n         ...props,\n         dispatch: () => { },\n         routes: new Map\n      })\n   }, [])\n\n   useEffect(() => {\n      core.currentGroup = prevGroupId\n      const get = core.groups.get(uid)\n      if (get) {\n         core.groups.set(uid, {\n            ...get,\n            dispatch: () => dispatch(Math.random()),\n         })\n      }\n      return () => {\n         core.groups.delete(uid)\n      }\n   }, [])\n\n   useEffect(() => {\n      const group = core.groups.get(uid)\n      if (group) {\n         let found = false;\n\n         group.routes.forEach((route, routeId) => {\n            const path = group.basepath ? `${group.basepath}${route.path}` : route.path\n            const params = Parser.isMatch(path, window.location.pathname) || false\n            if (params || route.params) {\n               group.routes.set(routeId, {\n                  ...route,\n                  params\n               })\n               route.dispatch()\n            }\n            if (!found && params) {\n               group.onFound && group.onFound(route)\n               found = true\n            }\n         })\n\n         if (!found) {\n            group.onError && group.onError()\n         }\n      }\n   }, [d])\n}\n\nexport interface useRouteProps {\n   path: string;\n}\nexport const useRoute = (path: string) => {\n   const uid = useId()\n   const [d, dispatch] = useState(0)\n   const groupId = useMemo(() => core.currentGroup, [])\n   const group = useMemo(() => groupId && core.groups.get(groupId), [])\n   useMemo(() => {\n      if (group) {\n         group.routes.set(uid, {\n            dispatch: () => { },\n            path,\n            params: false\n         })\n      }\n   }, [])\n\n   const params = useMemo(() => {\n      let _params: RoutesProps['params'] = Parser.isMatch(path, window.location.pathname) || false;\n\n      return _params\n   }, [d])\n\n   useEffect(() => {\n      if (group) {\n         group.routes.set(uid, {\n            dispatch: () => dispatch(Math.random()),\n            path,\n            params\n         })\n      }\n      return () => {\n         if (group) {\n            group.routes.delete(uid)\n         }\n      }\n   }, [])\n\n   return group && group.routes.get(uid)?.params\n}\n\nwindow.addEventListener('popstate', () => {\n   core.groups.forEach((group) => group.dispatch())\n})","import React, { ComponentType } from 'react'\nimport { useRoute } from '../core'\n\ntype RenderProps = {\n   params?: { [key: string]: any };\n}\n\nexport interface RouteProps {\n   path: string;\n   render: ComponentType<RenderProps>;\n}\n\nconst Route = ({ path, render: Render }: RouteProps) => {\n   const params = useRoute(path)\n   return params ? <Render params={params} /> : <></>\n}\n\nexport default Route","import Navigate from \"./navigate\"\nimport Link, { LinkProps } from \"./components/Link\"\nimport Route, { RouteProps } from \"./components/Route\"\nimport Routes, { RoutesProps } from \"./components/Routes\"\nimport Parser from \"./Parser\"\nexport { Link, Navigate, Routes, Route, Parser }\nexport type { LinkProps, RouteProps, RoutesProps }\nexport const useQuery = Parser.parseQuery\nexport * from './core'\n","import React, { ReactElement, ReactNode } from 'react'\nimport { useGroup, GroupProps } from '../core';\n\nexport type RoutesProps = Omit<GroupProps, 'dispatch' | 'routes'> & {\n   children: ReactElement | ReactNode\n}\n\nconst Routes = ({ children, ...props }: RoutesProps) => {\n   useGroup(props)\n   return <>{children}</>\n}\n\nexport default Routes"],"names":["navigate","go","path","window","history","pushState","pagex","dispatchEvent","PopStateEvent","state","reload","location","pathname","back","forward","Parser","isMatch","regex_path","matches","match","decode","decodeURIComponent","m","params","parseQuery","q","search","vars","substring","split","query","i","length","pair","core","currentGroup","groups","Map","actives","useGroup","props","uid","useId","useState","d","dispatch","prevGroupId","useMemo","set","routes","useEffect","get","Math","random","group","found","forEach","route","routeId","basepath","onFound","onError","useRoute","groupId","_group$routes$get","addEventListener","useQuery","href","children","label","createElement","component","noHref","onClick","e","preventDefault","Render","render","React"],"mappings":"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"}