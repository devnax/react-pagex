{"version":3,"file":"react-pagex.cjs.production.min.js","sources":["../src/Parser.ts","../src/factory.ts","../src/components/RouteProvider.tsx","../src/hooks/Router.ts","../src/hooks/useMatch.ts","../src/index.ts","../src/components/Link.tsx","../src/components/Route.tsx"],"sourcesContent":["import { match } from 'path-to-regexp'\n\n\nexport type Result = {\n   keys: string[];\n   pattern: RegExp;\n}\n\nexport type CallbackProps = { params: { [key: string]: string } }\nexport type Callback = (props: CallbackProps) => any;\n\nconst parseQuery = (q = window.location.search) => {\n   if (!q) return {}\n   const query_string = q.substring(1);\n   const vars = query_string.split('&')\n   const query: { [key: string]: string } = {}\n   for (var i = 0; i < vars.length; i++) {\n      var pair = vars[i].split('=');\n      query[pair[0]] = pair[1]\n      query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1])\n   }\n   return query\n}\n\nconst isMatch = (regex_path: string, path: string) => {\n   const m = match(regex_path, { decode: decodeURIComponent })\n   const matches = m(path)\n   return matches ? matches.params : null\n}\n\nconst Parser = {\n   isMatch,\n   parseQuery\n}\n\nexport default Parser","import Parser from \"./Parser\";\nexport type PathString = string\nexport type FactoryId = string\nexport interface FactoryItem {\n   id: string;\n   params: { [key: string]: any } | null;\n   path?: string;\n   dispatch: () => void;\n}\n\nexport const Factory = new Map<FactoryId, FactoryItem>()\n\nexport const Excute = () => {\n   let isMatched = false;\n   const invalids: FactoryItem[] = []\n\n   Factory.forEach((item, key) => {\n      if (item.params) {\n         Factory.set(key, { ...item, params: null })\n         item.dispatch()\n      }\n      if (item.path) {\n         const params = Parser.isMatch(item.path, window.location.pathname)\n         if (params) {\n            isMatched = true\n            Factory.set(key, { ...item, params })\n            item.dispatch()\n         }\n      } else {\n         invalids.push(item)\n      }\n   })\n\n   !isMatched && invalids.forEach((item) => {\n      Factory.set(item.id, { ...item, params: {} })\n      item.dispatch()\n   })\n}\n\nwindow.addEventListener('popstate', () => Excute())","import { useEffect } from 'react'\nimport { Excute } from '../factory'\ninterface Props {\n   children: any;\n}\n\nconst RouteProvider = ({ children }: Props) => {\n   useEffect(() => {\n      Excute()\n   }, [])\n   return children\n}\n\nexport default RouteProvider","const Router = {\n   go: (path: string) => {\n      window.history.pushState({ pagex: true, path }, \"\", path)\n      dispatchEvent(new PopStateEvent(\"popstate\", { state: { pagex: true, path } }))\n   },\n   reload: () => {\n      dispatchEvent(new PopStateEvent(\"popstate\", {\n         state: {\n            path: window.location.pathname,\n            pagex: true\n         }\n      }))\n   },\n   back: () => window.history.back(),\n   forward: () => window.history.forward()\n}\n\nexport default Router","import { useState, useMemo, useEffect, useId } from 'react'\nimport { Factory, PathString, FactoryItem } from \"../factory\"\nimport Parser from \"../Parser\";\n\nconst useMatch = (path?: PathString) => {\n   const id = useId()\n   const [, dispatch] = useState(0)\n\n   useMemo(() => {\n      let params = null\n      if (path) {\n         params = Parser.isMatch(path, window.location.pathname)\n      }\n      Factory.set(id, {\n         id,\n         params,\n         dispatch: () => { },\n         path\n      })\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, [])\n\n   useEffect(() => {\n      Factory.set(id, {\n         ...Factory.get(id) as FactoryItem,\n         dispatch: () => dispatch(Math.random())\n      })\n\n      return () => {\n         Factory.delete(id)\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n   }, [])\n\n   const item = Factory.get(id)\n   return item?.params\n}\n\n\nexport default useMatch","import RouteProvider from './components/RouteProvider'\nimport Router from \"./hooks/Router\"\nimport useMatch from \"./hooks/useMatch\"\nimport Link, { LinkProps } from \"./components/Link\"\nimport Route, { RouteProps } from \"./components/Route\"\nimport Parser from \"./Parser\"\nexport { RouteProvider, Link, useMatch, Router, Route, Parser }\nexport type { LinkProps, RouteProps }\n\nexport const useQuery = Parser.parseQuery\n","import { ComponentType, createElement, FC, ReactElement } from 'react'\nimport Router from '../hooks/Router'\n\nexport interface LinkProps {\n   children?: string | ReactElement;\n   label?: string;\n   href: string;\n   noHref?: boolean;\n   component?: ComponentType<any>\n}\n\n\nconst Link: FC<LinkProps> = ({ href, noHref, children, label, component }) => {\n   return createElement(component || 'a', {\n      ...(noHref !== false ? { href } : {}),\n      onClick: (e: any) => {\n         e.preventDefault()\n         Router.go(href)\n      }\n   }, children || label)\n}\n\nexport default Link","import React, { ComponentType } from 'react'\nimport useMatch from '../hooks/useMatch'\n\n\ntype RenderProps = {\n   params?: { [key: string]: any };\n}\n\nexport interface RouteProps {\n   path?: string;\n   render: ComponentType<RenderProps>;\n}\n\nconst Route = ({ path, render: Render }: RouteProps) => {\n   const params = useMatch(path)\n   return params ? <Render params={params} /> : <></>\n}\n\nexport default Route"],"names":["Parser","isMatch","regex_path","path","matches","match","decode","decodeURIComponent","m","params","parseQuery","q","window","location","search","vars","substring","split","query","i","length","pair","Factory","Map","Excute","isMatched","invalids","forEach","item","key","set","dispatch","pathname","push","id","addEventListener","Router","go","history","pushState","pagex","dispatchEvent","PopStateEvent","state","reload","back","forward","useMatch","useId","useState","useMemo","useEffect","get","Math","random","useQuery","href","children","label","createElement","component","noHref","onClick","e","preventDefault","Render","render","React"],"mappings":"mZAWA,IAmBMA,EAAS,CACZC,QAPa,SAACC,EAAoBC,GAClC,IACMC,EADIC,QAAMH,EAAY,CAAEI,OAAQC,oBACtBC,CAAEL,GAClB,OAAOC,EAAUA,EAAQK,OAAS,MAKlCC,WArBgB,SAACC,GACjB,YADiBA,IAAAA,EAAIC,OAAOC,SAASC,SAChCH,EAAG,MAAO,GAIf,IAHA,IACMI,EADeJ,EAAEK,UAAU,GACPC,MAAM,KAC1BC,EAAmC,GAChCC,EAAI,EAAGA,EAAIJ,EAAKK,OAAQD,IAAK,CACnC,IAAIE,EAAON,EAAKI,GAAGF,MAAM,KACzBC,EAAMG,EAAK,IAAMA,EAAK,GACtBH,EAAMX,mBAAmBc,EAAK,KAAOd,mBAAmBc,EAAK,IAEhE,OAAOH,ICXGI,EAAU,IAAIC,IAEdC,EAAS,WACnB,IAAIC,GAAY,EACVC,EAA0B,GAEhCJ,EAAQK,SAAQ,SAACC,EAAMC,GAKpB,GAJID,EAAKnB,SACNa,EAAQQ,IAAID,OAAUD,GAAMnB,OAAQ,QACpCmB,EAAKG,YAEJH,EAAKzB,KAAM,CACZ,IAAMM,EAAST,EAAOC,QAAQ2B,EAAKzB,KAAMS,OAAOC,SAASmB,UACrDvB,IACDgB,GAAY,EACZH,EAAQQ,IAAID,OAAUD,GAAMnB,OAAAA,KAC5BmB,EAAKG,iBAGRL,EAASO,KAAKL,OAInBH,GAAaC,EAASC,SAAQ,SAACC,GAC7BN,EAAQQ,IAAIF,EAAKM,QAASN,GAAMnB,OAAQ,MACxCmB,EAAKG,eAIXnB,OAAOuB,iBAAiB,YAAY,WAAA,OAAMX,OCjC1C,ICNMY,EAAS,CACZC,GAAI,SAAClC,GACFS,OAAO0B,QAAQC,UAAU,CAAEC,OAAO,EAAMrC,KAAAA,GAAQ,GAAIA,GACpDsC,cAAc,IAAIC,cAAc,WAAY,CAAEC,MAAO,CAAEH,OAAO,EAAMrC,KAAAA,OAEvEyC,OAAQ,WACLH,cAAc,IAAIC,cAAc,WAAY,CACzCC,MAAO,CACJxC,KAAMS,OAAOC,SAASmB,SACtBQ,OAAO,OAIhBK,KAAM,WAAA,OAAMjC,OAAO0B,QAAQO,QAC3BC,QAAS,WAAA,OAAMlC,OAAO0B,QAAQQ,YCV3BC,EAAW,SAAC5C,GACf,IAAM+B,EAAKc,UACFjB,EAAYkB,WAAS,MAE9BC,WAAQ,WACL,IAAIzC,EAAS,KACTN,IACDM,EAAST,EAAOC,QAAQE,EAAMS,OAAOC,SAASmB,WAEjDV,EAAQQ,IAAII,EAAI,CACbA,GAAAA,EACAzB,OAAAA,EACAsB,SAAU,aACV5B,KAAAA,MAGH,IAEHgD,aAAU,WAMP,OALA7B,EAAQQ,IAAII,OACNZ,EAAQ8B,IAAIlB,IACfH,SAAU,WAAA,OAAMA,EAASsB,KAAKC,cAG1B,WACJhC,SAAeY,MAGlB,IAEH,IAAMN,EAAON,EAAQ8B,IAAIlB,GACzB,aAAON,SAAAA,EAAMnB,QC1BH8C,EAAWvD,EAAOU,wBCGH,gBAAG8C,IAAAA,KAAcC,IAAAA,SAAUC,IAAAA,MACpD,OAAOC,kBADoDC,WACzB,UAChB,MAFgBC,OAER,CAAEL,KAAAA,GAAS,IAClCM,QAAS,SAACC,GACPA,EAAEC,iBACF5B,EAAOC,GAAGmB,MAEbC,GAAYC,mCCNJ,gBAAiBO,IAARC,OACdzD,EAASsC,IADD5C,MAEd,OAAOM,EAAS0D,gBAACF,GAAOxD,OAAQA,IAAa0D,wDLT1B,gBAAGV,IAAAA,SAItB,OAHAN,aAAU,WACP3B,MACA,IACIiC"}